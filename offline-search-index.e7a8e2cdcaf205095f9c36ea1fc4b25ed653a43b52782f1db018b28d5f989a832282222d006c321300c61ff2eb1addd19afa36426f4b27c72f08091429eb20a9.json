[{"body":"Version: 0.1.0\nDate: 28 October 2019\nStatus: Draft\nType: Guide\nID: 3G\nOverview Data can be packed more compactly than even the smallest primitive type allow by manipulating the individual bytes of the numbers. For example, an 8 bit unsigned integer (uint8_t) can contain the number from 0-255, 8 boolean flags, 4 two bit numbers (0-3), a combination of 3-bit numbers (0-8) and two bit number, 2 4-bit numbers (0-15), or any combination of these. In general, the smallest on-wire primitive type in modern programming languages are at least 8 bits wide, even boolean type which can only hold two states. In a bandwidth constrained application like long-distance radio signaling, every bit matters, and thus Bit manipulation become a handy method to pack more data in much less space.\nBasic Operations To manipulate numerical data types at the bit level, we must resort to binary operators such as AND(\u0026amp;), OR(|), XOR(|), and NOT(~). These follow the following truth tables (A,B are inputs, Y is the output):\nNOT\n   Y A     0 1   1 0    AND\n   Y A B     0 0 0   0 0 1   0 1 0   1 1 1    OR\n   Y A B     0 0 0   1 0 1   1 1 0   1 1 1    XOR\n   Y A B     0 0 0   1 0 1   1 1 0   0 1 1    These operations can be used formally to do boolean algebra. However, from a practical perspective, for data packing purposes, each of these operator have somewhat specific functions. An AND operator serves as a mask, allowing specific bits from a number to be \u0026ldquo;selected\u0026rdquo;. For instance:\nIN = 0b010100111 MASK = 0b000010100 # \u0026quot;selecting\u0026quot; bits 5 and 3 IN \u0026amp; MASK = 0b000000100 And the OR operator can be used to \u0026ldquo;set\u0026rdquo; bits\nIN = 0b00100000 SETBITS = 0b00100001 IN | SETBITS = 0b00100001 To unset bits, a combination and \u0026amp; and ~ can be used.\nAdditionally, there are the left shift(\u0026lt;\u0026lt;) and right shift(\u0026lt;\u0026lt;) operators, which \u0026ldquo;move\u0026rdquo; the number over a set number of bits and fill the rest of zeroes. For example:\n0b00011 \u0026lt;\u0026lt; 3 = 0b00011000 0b1010011 \u0026gt;\u0026gt; 4 = 0b101 Recipes Bit Flag Setting\nIN |= PATTERN \u0026lt;\u0026lt; n Where IN is an input variable, PATTERN is the pattern that need to get set, and n is the number of bits into the input where the pattern should get set. For instance:\nIN = 0b000110011 ~^ and we want to set the two underlined bits to 111, we\u0026rsquo;d do\nIN |= 0b11 \u0026lt;\u0026lt; 6 It is important to note that his can only set bits, if a bit is already one it cannot be converted to a zero.\nBit Flag Clearing\nTo clear bits, we follow the following recipe\nIN \u0026amp;= ~(PATTERN \u0026lt;\u0026lt; n) For example:\nIN = 0b0001010011 ~~^ and we want to clear the three underlined bits (set them back to zero), we\u0026rsquo;d use\nIN \u0026amp;= ~(0b111 \u0026lt;\u0026lt; 4) Reading bits\nOUT = IN \u0026amp; MASK For example, to read the 3 most significant bits from 0b0101100, we\u0026rsquo;d use\nOUT = IN \u0026amp; 0b1110000 # or OUT = IN \u0026amp; 0b111 \u0026lt;\u0026lt; 4 # OUT = 0b0100000 However the issue here is that the extracted bits will still be in their original columns, and thus will be as large as the originals. To remedy this, we can right shift by the number of bits to make the LSB of the masked output to be in the 2^0 place.\nOUT = (IN \u0026amp; MASK) \u0026gt;\u0026gt; n OUT = (IN \u0026amp; 0b1110000) \u0026gt;\u0026gt; n # out = 0b010 Thus, the easiest way to set a number of bits that might contains ones to a custom patters is to first clear those bits, then set using the OR operator.\nToggling\nFinally, toggling is pretty similar to the other two, except we use the Xor operator instead of OR or AND:\nIN ^= (PATTERN \u0026lt;\u0026lt; n) For example:\nIN = 0b00110011 ~~^ To toggle the three underlined bytes, we\u0026rsquo;d use:\nIN ^= (0b111 \u0026lt;\u0026lt; 5) # IN = 0b11010011 ","excerpt":"Version: 0.1.0\nDate: 28 October 2019\nStatus: Draft\nType: Guide\nID: 3G\nOverview Data can be packed …","ref":"/docs/guides/guide-bits/","title":"Bit Manipulations"},{"body":"Version: 0.1.0\nDate: 19 October 2019\nStatus: Draft\nType: System Specification\nOverview Propulsion Avionics shall be avionics systems that control and instrument the BJ-01 rocket engine during test runs (CFTs and hot fires) and full flights. This system is safety critical, and any changes shall be integration tested with propulsion components before flying.\nGoals  Minimize risk to anyone involved in propulsion system operations Ensure reliable ignition and operation of the BJ-01 rocket engine Collect propulsion system metrics for analysis  Requirements  Accept and log instrumentation data Initiate and monitor ignition process for the rocket engine Monitor instrumentation and alert operator(s) in case of malfunction and/or automatically act to minimize safety risk. Respond automatically to failures to minimize safety risk  Out of scope  Rocket operations after engine burn has completed (this is the domain of recovery avionics) Rocket operations before oxidizer fueling (this is the domain of the ground support hardware)  Components:  Data Acquisition Plane (DAP): Tasked with receiving and logging data from engine instrumentation Command \u0026amp; Control Plane (C2P): Tasked with receiving operator commands and sending the appropriate control signals to the engine (oxidizer valve and fueling solenoids). Also tasked with automatically responding to real-time data received from the DAQ. Data Transmission and Visualization plane (DTP): Tasked with transmitting data to the operator console. Must also visualize telemetry data easing identification of error conditions.  Data Acquisition Plane The data acquisition plane shall read and track the state of the following engine components:\n Thermocouples (TCs) Pressure transducers (PTs) Load cells (LCs) Solenoids Motorized valve  and log the output to a csv log at a sample rate of __ seconds. The log shall consist of one line per sample and E_[sensor] for any data collection errors. The log for each run shall be called log_[time] where [time] is the Unix timestamp. The DAQ shall also provide the DTP and C2P with updated data in every sample interval.\nCommand and Control Plane See the specification for a detailed treatment of this component.\n","excerpt":"Version: 0.1.0\nDate: 19 October 2019\nStatus: Draft\nType: System Specification\nOverview Propulsion …","ref":"/docs/specs/prop-avionics/spec-system/","title":"General"},{"body":"Version: 0.0.1\nDate: 29 September 2019\nStatus: Draft\nType: Meta-Specification\nID: 0M\nDescription All specifications must have the following components:\n Title Header Description or Overview section Requirements section  and may also contain a \u0026ldquo;Components\u0026rdquo; and \u0026ldquo;Implementation\u0026rdquo; section as deemed necessary. Specifications must be written in markdown or asciidoc syntax, to ensure that the plaintext is equally readable.\nTitle and Header The title should be a concise description of what the specification covers. All titles for specifications must be unique to prevent confusion.\nThe header serves as the \u0026ldquo;metadata\u0026rdquo; for the specification and should only contain the following fields:\n Version: Following semver specifications Date: Indicating the date that the specification was last updated Status: Indicating where the specification lies along the specification lifecycle Type: Describing what type of document it is. Must be one of the following values:  \u0026ldquo;Specification\u0026rdquo;: Engineering specifications for systems, formats, and components \u0026ldquo;Meta-Specification\u0026rdquo;: Specifications about specifications are specification lifecycle and usage.   ID: A unique number assigned to each spec when it reaches draft status that serves as an official alias.  When creating the header, each line should have two space characters ( ) to force a new line between each item.\nExample title and header # B System Specifications Version: 0.1.1 Date: 20 September 2019 Status: Draft Type: Meta-Specification Overview/Description This section shall contain a short description of the thing covered by the specification, as well as a brief overview specification conditions.\nRequirements This section shall list each requirement of an implementation that is in spec Each item listed here must be verified before the system is declared complete. Definitions written here shall follow meta-spec 1M \u0026ldquo;Keywords for use in specifications\u0026rdquo;\n","excerpt":"Version: 0.0.1\nDate: 29 September 2019\nStatus: Draft\nType: Meta-Specification\nID: 0M\nDescription All …","ref":"/docs/specs/meta-guidelines/","title":"Specification Guidelines"},{"body":"Version 1.0.0\nDate: 29 September 2019\nStatus: Current\nType: Meta Specification\nID: 1M based on rfc2119\nThe following keywords shall carry special meaning when used within a specification:\n SHALL: This word, and the words \u0026ldquo;REQUIRED\u0026rdquo; and \u0026ldquo;MUST\u0026rdquo;, mean that the definition is an absolute requirement of the specification. Implementations that fail to comply with one of these directives are always out of spec SHALL NOT: This phrase and the phrase \u0026ldquo;MUST NOT\u0026rdquo; mean an absolute prohibition of the specification. SHOULD: This word, or the word \u0026ldquo;RECOMMENDED\u0026rdquo;, mean that the definition is a strong recommendation of the specification that should be followed in the absence of a valid reason to diverge. Team members should seek advice from the subsystem lead before disregarding these directives. Divergences with documented justifications are within spec. SHOULD NOT: This phrase means a strong discouragement of the specification. MAY: This word means that the definition is completely optional recommendation of the specification and may be disregarded at will. Divergences are always within spec. MAY NOT: This words means that the directive is a completely optional prohibition of the specification.  ","excerpt":"Version 1.0.0\nDate: 29 September 2019\nStatus: Current\nType: Meta Specification\nID: 1M based on …","ref":"/docs/specs/meta-keywords/","title":"Specification Keywords"},{"body":"Version: 0.1.0\nDate: 29 September 2019\nStatus: Provisional Document\nType: Meta Specification\nID: 2M\nTemplate Copy and paste the following into a markdown file, edit out the placeholders, and remove unneeded portions.\n# Specifications for [system] Version: [version] Date: [Date] Status: [status] Type: System Specification ID: [ID] ## Overview [Required Section] This *word* is italicized. This **word** is bold. ## Goals [Optional Section] ## Requirements [Required Section] 1. This 2. is 3. an 4. ordered 5. list. ## Out of scope [Optional Section] - This - is - an - unordered - list. ## Componenets [Optional Section] ``` this is a prmformatted code block syntax highlighting will be automatically applied. ``` ## Implementation [Optional section] ## See also [Optional section] ","excerpt":"Version: 0.1.0\nDate: 29 September 2019\nStatus: Provisional Document\nType: Meta Specification\nID: 2M …","ref":"/docs/specs/meta-template/","title":"Specification Template"},{"body":"Version: 0.5.1\nDate: 28 October 2019\nStatus: Draft\nType: Component Specification\nOverview The command and control (C2) plane is responsible for communicating with onboard systems such as the engine, and ensure they remain responsive and under operator control at all times. Control signals shall be transmitted over 915Mhz LoRa radio\nI2C Protocol I2C shall be used as the inter-board communication method of choice between the custom controllers in this system. The I2C protocol should follow the following\nDevice IDs\n   Address Device     10 Engine Controller   11 Ground Valve Controller   48 ADC (for PTs)    To get the current EC state, request a single byte over I2C.\nEC State packet\n   Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0     null null null Req MV-G1 State eMatch MV-R1 MV-R1 moving MV-S1    The EC will accept the following single byte write to set modifiable state\nEC Command Packeta\n   Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0     null null null null null Vent Vent E Shutdown     Vent is a two bit number to contain all of its states, with MSB at Bit 2 and LSB at bit 1.  Since the PI serves as the bus master, it should check the Requested MV-G1 State and compare it to the last one sent to the Ground valve controller. If it is different it should construct a single byte command packet with value 1 and sent it to the Ground valve Controller.\nRadio protocol The Ground Station, Relay Box and Ignition computer shall all implement the C2 over 915Mhz LoRa radio. Each packet sent over the LoRa network shall follow the following format:\n   Packet Byte Description     0 Sender/Receiver ID byte   1 Packet Type   2\u0026hellip;n Packet Payload    Bytes 0-1 are considered the \u0026ldquo;header\u0026rdquo; of the packet and primarily serve as metadata that allow receivers to choose how to handle packets with minimal overhead.\nThe sender/receiver ID shall be an 8 bit integer (uint8_t) with the high 4 bits representing the sender ID and the low 4 bits representing the receiver ID. That is:\n0b11110000 will be split into Sender ID = 0b1111 = 15 Receiver ID = 0b0000 = 0 These IDs must follow the table below:\n   C2 Plane Component ID     Ground Station 0   Ignition (Engine) Computer 1   Relay Box Controller 2   Broadcast 15    NOTE: ID #15 is reserved for broadcast messages sent to all radio devices on the same network and thus the maximum devices that can be connected to the same network as of this spec is 15.\nThus, if the Ground Station were to send a packet to the Ignition Computer, it would send 0b00000001 in the 1 byte of its radio packet. This also means that the sender of a packet can be determined by parsing byte 1 of the packet.\nPacket types must be one of the following:\n   Packet Type Code     NOOP (does nothing) 0   GS State Command 1   Heartbeat Request 2   ACK 100   NACK 101    Synchronization and Acknowledgemen The C2 plane uses an acked radio protocol. This means that every command sent from the Grand Station to the rocket must be acknowledged by a corresponding packet from the rocket to be considered successfully transmitted. However, since only the newest state of the ground station needs to be carried out by the rocket, only the latest command packet will need to be acked.\nrepeat forever: if button state changed from last transmitted state: record state of GS assign sequence code to state so ack can be track replace current state pending ack send state to rocket otherwise: if state transmission is pending ack check for ack with matching sequence number from rocket, if received, mark state as acked if no response, and time is over ack timeout: resend only if there are retries left, otherwise light up transmission error led Heartbeat Request Packet Format:\n   Packet Byte Content     0-1 HEADER   2 Sequence Code    ACK Packet Format:\n   Packet Byte Content     0-1 HEADER   2 Sequence Code    The sequence code is a pseudo-unique code that matches request packets with their corresponding ACK packets. Sequence codes should be incremented after every ack\u0026rsquo;d packet transmission and should roll over at 256 (uint8_t will do this automatically). All ack\u0026rsquo;d packets transmitted from the same node should use and increment the same sequence node counter to ensure that all packets transmitted in a short time window from the node have different sequence codes. Packets that require acknowledgement should include a sequence code so the resulting ack can be tracked back to the originating request.\nValve Control Valve Control Packet\n   Packet Byte Content     0-1 HEADER   2 Sequence Code   3 Ball Valve State   4 Vent State   5 Fuel Valve State    The ignition computer receives valve control commands from the operator. Corresponding control signals are then sent to the propulsion system. Radio commands for each valve shall be represented by an integer value, should be of the int8_t type. As there are 3 valves, a radio command shall be an array containing 3 integers of the following order:\n Open/Close of fuel-combustion ball valve Open/Close of fueling solenoid valve Open/Close of venting solenoid valve  The commands values used by each of the command is outlined in the following tables. Note, the values here are only used at software level, whilst the actual signals sent to hardware components need to be defined based on the particular needs.\nBall valve control\n   value Description     0 Standby signal that does not lead to any change in current valve action.   1 Reversed movement of the valve.   2 Forward movement of the valve.   255 signal for Ignition Sequence, including opening the valve for a preset amount of time, before closing.    Venting solenoid valve control\n   value Description     0 Standby Signal, with no change in current valve action   1 Closing of the venting valve   2 Opening of the venting valve    Fuel solenoid valve control\n   value Description     0 Standby Signal, with no change in current valve action   1 Closing of the Fuel valve   2 Opening of the Fuel valve    One example of a command would be {1,-1,0}, denoting the unlikely command of forward action of ball valve, no change in action of venting valve, and the closing of fuel valve. For future expansion of the commands, it is recommended that any simple command should obtain a value ascending from 1, whilst complex sequence command should obtain a value descending from 127. For the valves used, Simple and sequence commands are defined as:\n Simple command is a command that is accomplished by #one# #continuous# and #unidirectional# action of the valve. Sequence commands is a command that is accomplished by #multiple# #discontinuous(e.g. with intervals)# and/or #multidirectional# action of the valve.  ","excerpt":"Version: 0.5.1\nDate: 28 October 2019\nStatus: Draft\nType: Component Specification\nOverview The …","ref":"/docs/specs/prop-avionics/spec-control-plane/","title":"Control Plane"},{"body":"PLACEHOLDER\n","excerpt":"PLACEHOLDER","ref":"/docs/","title":"Documentation"},{"body":"PLACEHOLDER\n","excerpt":"PLACEHOLDER","ref":"/docs/guides/","title":"Guides"},{"body":"PLACEHOLDER\n","excerpt":"PLACEHOLDER","ref":"/docs/specs/","title":"Specifications"},{"body":"PLACEHOLDER\n","excerpt":"PLACEHOLDER","ref":"/docs/specs/prop-avionics/","title":"Specifications for Propulsion Avionics"},{"body":"DartPlot Utility Specifications Version: 0.1.0\nDate: 14 September 2019\nStatus: Current\nType: Software Specification\nID: 4S\nDescription dartplot is a utility that takes a complete csv flight log as the input. It will output plots for each of the sensors of interest in the form of png images.\nRequirements The following quantities will be plotted against time (t):\n 6 thermocouples (Header name TC#) 3 loadcells against time (Header name LC#) 4 pressure transducers (Header name PT#)  The utility will output to folder called plots by default, in the directory the script was run in.\nThe following will also be plotted:\n 1 red horizontal line at critical pressure and critical temperature boolean sensor monitor  Future Considerations  Continuous monitor? Find a way to process data faster?  ","excerpt":"DartPlot Utility Specifications Version: 0.1.0\nDate: 14 September 2019\nStatus: Current\nType: …","ref":"/docs/spec-dartplot/","title":""},{"body":"","excerpt":"","ref":"/","title":"Astrojays Rocketry"}]